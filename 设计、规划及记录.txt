贪吃蛇的初步设想:


项目需求(初步):

1.需要一个主界面(框)

2.需要一条蛇(程序)

3.需要随机的块(食物)

4.需要灵活的控制(至少两个按键,分别控制左侧掉头90°和右侧掉头90°)

5.需要一套死亡判定规则(贯穿,或独立的死亡判定，及死亡后的提示界面)


分步实现(初步):

1.主界面框:
	采用ncurese库,划定一个窗口，并在边沿围上一圈围墙,初步设计围墙用'#'代替

2.蛇:
	(1) 蛇体:
		初步设想为结构体数组或结构体链表,每节蛇体内两个参数(或3个),分别代表纵坐标,横坐标(和下一节点)
	(2) 蛇的显示及运动:
		独立的子函数,通过调用子函数实现蛇体的增长,这里可以连带实现蛇体转弯效果及死亡的判定
		初步设想,函数形参为"蛇体","方位","食物块(坐标)",返回值为蛇体(结构体(数组)的指针)
		函数内:
			① 根据左右(0,代表直走 1,代表左拐 2,代表右拐)决定下一步走向,并循环改变整蛇的位置
			② 对于已经改变位置的蛇的蛇头块进行判定,是否为食物,是则增长蛇体,并返回蛇体
			③ 对于已经改变位置的蛇的蛇头块进行判定,是否为蛇体或墙壁,是则返回NULL(0)
		蛇的显示:
			调用蛇运动函数后,对返回值进行判定,若返回为蛇体,接收蛇体并循环显示蛇体,接收返回值为NULL时,计算蛇体长度,free蛇体,并显示蛇死界面(其中包含蛇体长度)

3.食物块采用子函数套随机数函数,随机生成横纵坐标(注意范围),备用

4.ncurese库的键盘捕获函数,初步设想为A=1和D=2代表左右

5.死亡判定框外或咬自己+死亡界面函数(显示snake died及蛇长)

//大概设想如上
//

//以下为遇到的问题及改进
1.可以直接输出字符，选择暂时放弃ncurses库
2.输入控制:
	原本打算写一个直接获取键盘的函数(如kbin.h),但依然需要暂停获取输入,遂放弃
	后想到shell命令"read -t [time]",可以直接定时获取输入,随即想到system()调用,但返回值不合适,放弃system()(参见syst.c代码)
	百度得到popen()函数,创建一个管道(pip),通过fork新进程执行标准输入输出操作,计划采用popen(),百度搜索后得,
	https://blog.csdn.net/u012359618/article/details/52329346(linux脚本read的用法)
	https://blog.csdn.net/stone8761/article/details/77498439(popen 使用方法)
	https://blog.csdn.net/wang740209668/article/details/53500902(Linux-shell编程之接收键盘输入read命令)
	初步实现:
		char buf;
		//读取键盘
		fp = popen("read -s -a array -t 1.2 -n 1; echo $array", "r");
		//获取内容到字符变量
		while(memset(buf, 0, sizeof(buf)), fgets(buf, sizeof(buf) - 1, fp) != 0 ) {
                printf("输出%c", buf);
        }
3.显示
	
	二维大数组,全显示
	食物块始终存在,蛇的位置始终在内部(撞墙时在边沿)
	通过蛇的位置和食物块直接找到对应块替换,运行快,但耗费内存稍多(或直接判断输出,耗费时间,但节省内存)
4.食物块
	随机生成食物块,但要注意食物块不能生成在边界上(及界外),不能生成在蛇上,程序采用全循环判断的方法,可以预见的,随着蛇越来越长,生成食物块需要的时间也就越多,最终造成程序卡顿
5.蛇长
	蛇体占满多大的显示区域时结束程序？完全占满显示区域可不可能?

